import os
from commons.time_interval import TimeInterval
from commons.Timelist import TimeList
from basins.region import Rectangle

import instruments
import scipy.io.netcdf as NC
import numpy as np

import matchup


class Matchup_Manager():
    
    '''
    Main class for Float Matchup generation.
    '''
    def __init__(self,timeinterval,INPUTDIR,Outpudir):
        '''
                Outpudir is intended as the outputdir of aveScan, 
        point profiles will be produced in outputdir/PROFILES.
        '''
        self.profilingDir=Outpudir
        self.AVE_INPUT_DIR = INPUTDIR
        if os.path.exists(INPUTDIR):
            self.TL = TimeList(timeinterval, self.AVE_INPUT_DIR,"ave*.nc",'../postproc/IOnames.xml')
            self.TI = timeinterval
            All_Med = Rectangle(-6,36,30,46)
            self.PROFILE_LIST = instruments.Selector(None, self.TI, All_Med)
            datetimelist = [f.time for f in self.PROFILE_LIST]
            self.Coupled_List = self.TL.couple_with(datetimelist)
        else:
            print INPUTDIR + " not existing"

    def _dump_punti_for_aveScan(self,Profilelist,filename):
        LINES=[]
        LINES.append('NOME    Longitutine E    Latitudine N \n')
        for p in Profilelist:
            line = "%s %g %g \n" %(p.name(), p.lon, p.lat)
            LINES.append(line)
        
        F = open(filename, "w")
        F.writelines(LINES)
        F.close()

    def writefiles_for_profiling(self, filename):
        '''
        Preparation of launch of aveScan.py, in order to generate profiles.
        
        The file produced - first argument - is a wrapper of aveScan, to call it over times.
        For every launch of aveScan a different punti*.dat files will be used, depending on Biofloats present
        at that time.
        
        
        '''
        
        TMPSDIR =           self.profilingDir + "TMP/"
        PUNTI_DIR =         self.profilingDir + "PUNTI/"
        
        os.system("mkdir -p "+ PUNTI_DIR)
        JOB_LINES=[]
        
        JOB_LINES.append("export MASKFILE=/pico/home/usera07ogs/a07ogs00/OPA/V4/etc/static-data/MED1672_cut/MASK/meshmask.nc \n")
        JOB_LINES.append("export SUBMASKFILE=/pico/home/usera07ogs/a07ogs00/OPA/V4/etc/static-data/POSTPROC/submask.nc \n")
        JOB_LINES.append("cd ../postproc \n")
        for t in self.Coupled_List:
            Model_time        = t[0]
            INTERESTED_PROFILES = [self.PROFILE_LIST[k] for k in t[1]] #t[1]

            
            outpuntifile= PUNTI_DIR + "punti_" + Model_time.strftime("%Y%m%d") + ".dat" #punti_20150416.dat
            self._dump_punti_for_aveScan(INTERESTED_PROFILES, outpuntifile)
            line = 'python aveScan.py '   + \
                ' -l '  + Model_time.strftime("ave.%Y%m%d*")  + \
                ' -i '  + self.AVE_INPUT_DIR  +  \
                ' -t '  + TMPSDIR  + \
                ' -o '  + self.profilingDir  + \
                ' -d VarDescriptorB.xml ' + \
                ' -p ' + outpuntifile + '\n'
            JOB_LINES.append(line)
        
        F=file(filename,'w')
        F.writelines(JOB_LINES)
        F.close()


    
    def dumpModelProfiles(self,profilername):
        '''
        The text file provided as argument 
         - becomes executable
         - it is launched on cluster
         A series of aveScan.py are executed, once and for all the following analysis.
        '''
        
        MODEL_PROFILES_DIR =self.profilingDir + "PROFILES/"
        TMPSDIR =           self.profilingDir + "TMP/"
        os.system("mkdir -p " + MODEL_PROFILES_DIR)
        os.system("mkdir -p " + TMPSDIR)
        os.chmod(profilername, 0755)
        os.system(profilername)

    def readModelProfile(self, filename,var, wmo):
        '''
        Reads profiles produced by aveScan.py.
        In these files each variable has dimensions (jpk, nProfiles)
        And each profile is identified by the corresponding wmo
        '''
        ncIN = NC.netcdf_file(filename,'r')
        
        M = ncIN.variables[var].data.copy()
        iProfile = ncIN.CruiseIndex.rsplit(", ").index(wmo)
        ncIN.close()
        Profile = M[iProfile,:]
        
        return Profile

    def modeltime(self,profile):
        for Model_time,INTERESTED_Indices in self.Coupled_List:
            if profile in [self.PROFILE_LIST[k] for k in INTERESTED_Indices]:
                break
        return Model_time
    
    def getMatchups(self,Profilelist,nav_lev,model_varname,ref_varname):
        ''' 
        Float list is a list of Bio_Float objects 
        It depends on a user selection in space and time
        
        SingleFloatMatchup is created with 
          - good model values (no nans)
          - good float values (no nans) 
        
        The matchups are couples of values (Model,Ref) 
        obtained to a given selection in space and time,
        to be used in statistics.
        Matchups are generated by interpolation from model space to observation space.
        
        At the moment it can happen that a short model profile is extrapolated over a long float profile.
        Then, a replication of matchups could occur.
        
        Returns a FloatMatchup istance.
        '''
    
        Group_Matchup = matchup.matchup.ProfilesMatchup()
        
        
        for p in Profilelist:
            Model_time = self.modeltime(p)
            Modelfile = self.profilingDir + "PROFILES/" + Model_time.strftime("ave.%Y%m%d-%H:%M:%S.profiles.nc")
            ModelProfile = self.readModelProfile(Modelfile, model_varname, p.name())
            seaPoints = ~np.isnan(ModelProfile)
                    
            if np.isnan(ModelProfile).all() : # potrebbe essere fuori dalla tmask         
                print "No model data for (lon,lat) = (%g, %g) " %(p.lon, p.lat)
                continue
            
            Pres, Profile = p.read(ref_varname)
            
            MODEL_ON_SPACE_OBS=np.interp(Pres,nav_lev[seaPoints],ModelProfile[seaPoints]).astype(np.float32)
                    
            Matchup = matchup.matchup.ProfileMatchup(MODEL_ON_SPACE_OBS, Profile, Pres,p)
            
            Group_Matchup.extend(Matchup)
    
            
        return Group_Matchup 





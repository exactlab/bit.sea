import Float_Manager
from postproc.Timelist import TimeList
from basins.region import Rectangle
import scipy.io.netcdf as NC
import numpy as np
import matchup
import os

class Float_Matchup_Manager():
    
    '''
    Main class for Float Matchup generation.
    '''
    def __init__(self,DATESTART,DATE__END,INPUTDIR):
        self.profilingDir='BasedirToDefine'
        self.AVE_INPUT_DIR = INPUTDIR
        if os.path.exists(INPUTDIR):
            self.TL = TimeList(DATESTART, DATE__END, self.AVE_INPUT_DIR,"ave*.nc",'../postproc/IOnames.xml')
            self.TI = Float_Manager.Time_Interval(DATESTART,DATE__END,'%Y%m%d-%H:%M:%S')
            All_Med = Rectangle(-6,36,30,46)
            self.FLOAT_LIST=Float_Manager.FloatSelector(None, self.TI, All_Med)
            datetimelist = [f.time for f in self.FLOAT_LIST]
            self.Coupled_List = self.TL.couple_with(datetimelist)
        else:
            print INPUTDIR + " not existing"


    def _dump_punti_for_aveScan(self,Floatlist,filename):
        LINES=[]
        LINES.append('NOME    Longitutine E    Latitudine N \n')
        for f in Floatlist:
            line = "%s %g %g \n" %(f.wmo,f.lon, f.lat)
            LINES.append(line)
        
        F = open(filename, "w")
        F.writelines(LINES)
        F.close()

    def writefiles_for_profiling(self, filename, outputdir):
        '''
        Preparation of launch of aveScan.py, in order to generate profiles.
        
        The file produced - first argument - is a wrapper of aveScan, to call it over times.
        For every launch of aveScan a different punti*.dat files will be used, depending on Biofloats present
        at that time.
        Outpudir is intended as the outputdir of aveScan, 
        point profiles will be produced in outputdir/PROFILES.
        
        
        '''
        
        self.profilingDir = outputdir
        TMPSDIR =           self.profilingDir + "TMP/"
        PUNTI_DIR =         self.profilingDir + "PUNTI/"
        
        os.system("mkdir -p "+ PUNTI_DIR)
        JOB_LINES=[]
        
        JOB_LINES.append("export MASKFILE=/pico/home/usera07ogs/a07ogs00/OPA/V4/etc/static-data/MED1672_cut/MASK/meshmask.nc \n")
        JOB_LINES.append("export SUBMASKFILE=/pico/home/usera07ogs/a07ogs00/OPA/V4/etc/static-data/POSTPROC/submask.nc \n")
        JOB_LINES.append("cd postproc \n")
        for t in self.Coupled_List:
            Model_time        = t[0]
            INTERESTED_FLOATS = [self.FLOAT_LIST[k] for k in t[1]] #t[1]

            
            outpuntifile= PUNTI_DIR + "punti_" + Model_time.strftime("%Y%m%d") + ".dat" #punti_20150416.dat
            self._dump_punti_for_aveScan(INTERESTED_FLOATS, outpuntifile)
            line = 'python aveScan.py '   + \
                ' -l '  + Model_time.strftime("ave.%Y%m%d*")  + \
                ' -i '  + self.AVE_INPUT_DIR  +  \
                ' -t '  + TMPSDIR  + \
                ' -o '  + self.profilingDir  + \
                ' -d VarDescriptorB.xml ' + \
                ' -p ' + outpuntifile + '\n'
            JOB_LINES.append(line)
        
        F=file(filename,'w')
        F.writelines(JOB_LINES)
        F.close()


    
    def dumpModelProfiles(self,profilername):
        '''
        The text file provided as argument 
         - becomes executable
         - it is launched on cluster
         A series of aveScan.py are executed, once and for all the following analysis.
        '''
        
        MODEL_PROFILES_DIR =self.profilingDir + "PROFILES/"
        TMPSDIR =           self.profilingDir + "TMP/"
        os.system("mkdir -p " + MODEL_PROFILES_DIR)
        os.system("mkdir -p " + TMPSDIR)
        os.system(profilername)

    def readModelProfile(self, filename,var, wmo):
        '''
        Reads profiles produced by aveScan.py.
        In these files each variable has dimensions (jpk, nProfiles)
        And each profile is identified by the corresponding wmo
        '''
        ncIN = NC.netcdf_file(filename,'r')
        
        M = ncIN.variables[var].data.copy()
        iProfile = ncIN.CruiseIndex.rsplit(", ").index(wmo)
        ncIN.close()
        Profile = M[iProfile,:]
        
        return Profile
    
    
    def getMatchups(self,FloatList,nav_lev,model_varname,ref_varname):
        ''' 
        Float list is a list of Bio_Float objects 
        It depends on a user selection in space and time
        
        SingleFloatMatchup is created with 
          - good model values (no nans)
          - good float values (no nans) 
        
        The matchups are couples of values (Model,Ref) 
        obtained to a given selection in space and time,
        to be used in statistics.
        Matchups are generated by interpolation from model space to observation space.
        
        At the moment it can happen that a short model profile is extrapolated over a long float profile.
        Then, a replication of matchups could occur.
        
        Returns a FloatMatchup istance.
        '''
    
        Group_Matchup = matchup.matchup.FloatMatchup()
        
        
        for f in FloatList:
            for Model_time,INTERESTED_Indices in self.Coupled_List:
                if f.filename in [self.FLOAT_LIST[ii].filename for ii in INTERESTED_Indices]:
                    break
            Modelfile = self.profilingDir + "PROFILES/" + Model_time.strftime("ave.%Y%m%d-%H:%M:%S.profiles.nc")
            ModelProfile = self.getModelProfile(Modelfile, model_varname, f.wmo)
            seaPoints = ~np.isnan(ModelProfile)
                    
            if np.isnan(ModelProfile).all() : # potrebbe essere fuori dalla tmask         
                print "No model data for (lon,lat) = (%g, %g) " %(f.lon, f.lat)
                continue
            
            FloatPres, FloatProfile = f.read(ref_varname)
            
            MODEL_ON_SPACE_OBS=np.interp(FloatPres,nav_lev[seaPoints],ModelProfile[seaPoints]).astype(np.float32)
                    
            Matchup = matchup.matchup.SingleFloatMatchup(MODEL_ON_SPACE_OBS, FloatProfile, FloatPres,f)
            
            Group_Matchup.extend(Matchup)
    
            
        return Group_Matchup 





from os.path import exists, join
from os import fsync, rename
from time import sleep

import ftplib
import traceback
import threading


# The following class is a workaround for the fact
# that the strings are immutable. In this way we can
# send an ErrorMessage object to a function that can
# change it 
class ErrorMessage(object):
    """A class to handle error messages"""
    def __init__(self):
        # self.message contains the error
        self.message = None

class DownloadError(Exception):
    pass

def _read_permissions(txt):
    # Take the string of permissions generated by ls and returns
    # the same information in a more pythonic way
    assert len(txt) == 9
    output = dict()
    output['owner']  = set()
    output['group']  = set()
    output['others'] = set()
    if txt[0] =='r':
        output['owner'].add('read')
    if txt[1] == 'w':
        output['owner'].add('write')
    if txt[2] == 'x':
        output['owner'].add('execute')
    if txt[3] == 'r':
        output['group'].add('read')
    if txt[4] == 'w':
        output['group'].add('write')
    if txt[5] == 'x':
        output['group'].add('execute')
    if txt[6] == 'r':
        output['others'].add('read')
    if txt[7] == 'w':
        output['owner'].add('write')
    if txt[8] == 'x':
        output['others'].add('execute')
    return output


def list_files(connection):
    # Unfortunately, the standard library for the ftp connections
    # in python does not have a method to have a list of directories
    # or files inside a folder. All that we have is the output of
    # the ls command of the ftp server and a list of the files names.
    # This function return a tuple with the files and the directories.
    # The last element of the tuple is a dictionary with the file
    # permissions
    ls_output = []
    connection.dir('.', ls_output.append) 
    try:
        file_names = connection.nlst()
        file_names_set = set(file_names)
    except ftplib.error_perm as resp:
        if str(resp) == "550 No files found":
            return ([], [], dict())
        else:
            raise
    if len(file_names)==0:
        return ([], [], dict())

    # Now I divide the ls_output in two columns. In the second one
    # there are the filenames, in the first one all the other
    # informations.
    second_col = None
    min_len = min([len(l) for l in ls_output])
    for i in range(min_len)[::-1]:
        end_table_set = set([l[i:] for l in ls_output])
        if end_table_set == file_names_set:
            second_col = i
            break
    if second_col is None:
        return list_files_backup(ls_output)

    # Now I prepare the output.
    files = []
    dirs = []
    permissions = dict()
    for f in file_names:
        isdir = [l.startswith('d') for l in ls_output 
                                   if l[second_col:]==f][0]
        if isdir:
            dirs.append(f)
        else:
            files.append(f)
            perms = [l[1:10] for l in ls_output
                             if l[second_col:]==f][0]
            permissions[f] = _read_permissions(perms)

    return files, dirs, permissions



def download_file(connection, f, path, perms, log,
                  skip_if_exists=True, skip_is_strange = False):
    if skip_if_exists:
        # Check if the file already exists
        if exists(join(path, f)):
            if skip_is_strange:
                log.info('Skipping file ' + f + ' because'
                         ' it was already downloaded!')
            else:
                log.debug('Skipping file ' + f + ' because '
                          'it was already downloaded')
            return False

    # Check if the file is readable
    if 'read' not in perms[f]['others']:
        log.info('The file ' + f + ' is not '
                 'readable. Check the '
                 'permissions')
        return False
 
    # Download the file
    err_msg = ErrorMessage()
    log.debug('Downloading ' + f + '...')
    
    # I will first save the partial file with a temp name. When the
    # transfers end, I will rename it
    file_path = join(path, f)
    temp_name = join(path, 'incomplete_download.tmp')

    # The transfer will be executed by another thread. So I will write here
    # the function that the new tread will execute
    def background_transfer():
        # Open the temporary file
        try:
            with open(temp_name, 'wb') as loc_file:
                # Open the socket for the connection
                connection.voidcmd('TYPE I')
                transf_socket = connection.transfercmd('RETR ' + f)

                while True:
                    block = transf_socket.recv(2*1024)
                    if not block:
                        # If no more data, the download is complete
                        break
                    loc_file.write(block)

                transf_socket.close()
                connection.voidresp()

                # Ensure everything is written on the disk
                loc_file.flush()
                fsync(loc_file.fileno())
        except:
            try:
                transf_socket.close()
            except:
                pass
            err_msg.message = traceback.format_exc()


    # Start the thread that will download the file
    thread = threading.Thread(target=background_transfer)
    thread.start()
        
    # While I wait for the download, I will keep the connection
    # open. This solve a problem of timeouts with the ftp protocol
    while thread.is_alive():
        thread.join(30)
        connection.sendcmd('NOOP')
        
    # If there is an error, the download is failed
    if err_msg.message != None:
        raise DownloadError("Download failed: This is the traceback: \n"
                             + str(err_msg.message))

    
    # Move the temp file in the new downloaded file
    rename(temp_name, file_path)
    
    log.debug('File ' + f + ' downloaded!')
    return True



def list_files_backup(ls_output):
    # If the ls output is not properly aligned (this means that
    # there is a rows which is not aligned with the others) then
    # the standard list_files function will fail. This will works
    # but requires that the time column contains exactly two space
    # for every entries (for example Jun 23 2015).

    files = []
    dirs = []
    permissions = dict()

    perms = None
    num = None
    user = None
    group = None
    size = None
    date = None
    name = None
    
    for l in ls_output:
        perms = l.split()[0]
        l = l[len(perms):].lstrip()
        num = int(l.split()[0])
        l = l[len(str(num)):].lstrip()
        user = l.split()[0]
        l = l[len(user):].lstrip()
        group = l.split()[0]
        l = l[len(group):].lstrip()
        size = int(l.split()[0])
        l = l[len(str(size)):].lstrip()
        date = " ".join(l.split()[:3])
        l = l[len(date)+1:]
        name = l
    
        isdir = perms.startswith('d')
        if isdir:
            dirs.append(name)
        else:
            files.append(name)
            permissions[name] = _read_permissions(perms[1:])

    return files, dirs, permissions
        
    
